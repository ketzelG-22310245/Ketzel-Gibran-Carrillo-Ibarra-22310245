"""
Akinator de Pel√≠culas (Prototipo)
- √Årbol din√°mico de preguntas (s√≠/no/no s√©)
- Red neuronal ligera (MLPClassifier) que predice pel√≠cula seg√∫n respuestas
- Aprendizaje: si falla, el usuario suministra la pel√≠cula y el camino/respuestas se almacenan
- Persistencia: db.json (pel√≠culas, preguntas, partidas) + model.joblib para el clasificador
"""

import json
import os
from collections import defaultdict
from typing import List, Dict, Any
import joblib
import numpy as np

# ML libs
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import LabelEncoder

DB_FILE = "db.json"
MODEL_FILE = "model.joblib"

# --- Utilidades DB ---------------------------------------------------------
def cargar_db() -> Dict[str, Any]:
    if os.path.exists(DB_FILE):
        with open(DB_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    # DB inicial si no existe
    db = {
        "preguntas": [
            {"id": "genero_sf", "texto": "¬øLa pel√≠cula es de ciencia ficci√≥n?", "atributo": "genero", "valor": "Ciencia ficci√≥n"},
            {"id": "es_accion", "texto": "¬øLa pel√≠cula es de acci√≥n?", "atributo": "genero", "valor": "Acci√≥n"},
            {"id": "es_romance", "texto": "¬øLa pel√≠cula es de romance?", "atributo": "genero", "valor": "Romance"}
        ],
        "peliculas": [
            # ejemplos iniciales opcionales
            {"titulo": "Inception", "atributos": {"genero": "Ciencia ficci√≥n"}, "camino": []},
            {"titulo": "Titanic", "atributos": {"genero": "Romance"}, "camino": []},
            {"titulo": "Avengers: Endgame", "atributos": {"genero": "Acci√≥n"}, "camino": []}
        ],
        "partidas": []  # historial de partidas (camino de preguntas/respuestas)
    }
    guardar_db(db)
    return db

def guardar_db(db: Dict[str, Any]):
    with open(DB_FILE, "w", encoding="utf-8") as f:
        json.dump(db, f, indent=2, ensure_ascii=False)

# --- Representaci√≥n de caracter√≠sticas -------------------------------------
def preguntas_ids_ordenadas(db):
    # Mantener orden consistente de preguntas para vectores
    return [p["id"] for p in db["preguntas"]]

def respuestas_a_vector(respuestas: Dict[str, str], preguntas_ids: List[str]) -> List[float]:
    # Mapear 's√≠'->1, 'no'->0, 'no s√©'->0.5 (valor intermedio)
    vector = []
    for pid in preguntas_ids:
        r = respuestas.get(pid, None)
        if r is None:
            vector.append(0.5)  # indefinido -> neutro
        else:
            if r.lower() in ("s√≠", "si", "s", "yes", "y"):
                vector.append(1.0)
            elif r.lower() in ("no", "n"):
                vector.append(0.0)
            else:
                vector.append(0.5)
    return vector

# --- Entrenamiento y modelo -----------------------------------------------
class ModelManager:
    def __init__(self):
        self.model = None
        self.le = None  # label encoder for movie titles

    def entrenar(self, db):
        X = []
        y = []
        preguntas_ids = preguntas_ids_ordenadas(db)
        # Usar partidas y tambi√©n el campo 'camino' en peliculas
        muestras = []
        for partida in db.get("partidas", []):
            muestras.append(partida)
        for peli in db.get("peliculas", []):
            if peli.get("camino"):
                muestras.append({"titulo": peli["titulo"], "camino": peli["camino"]})
        # Construir X,y
        for m in muestras:
            respuestas = {step["id"]: step["respuesta"] for step in m.get("camino", [])}
            vec = respuestas_a_vector(respuestas, preguntas_ids)
            X.append(vec)
            y.append(m["titulo"])
        if len(X) < 4:
            # No hay suficientes muestras para entrenar un MLP confiable
            self.model = None
            self.le = None
            return
        X = np.array(X)
        self.le = LabelEncoder()
        y_enc = self.le.fit_transform(y)
        clf = MLPClassifier(hidden_layer_sizes=(32,), max_iter=500, random_state=42)
        clf.fit(X, y_enc)
        self.model = clf
        # Guardar a disco
        joblib.dump({"model": self.model, "le": self.le}, MODEL_FILE)

    def cargar(self):
        if os.path.exists(MODEL_FILE):
            data = joblib.load(MODEL_FILE)
            self.model = data.get("model")
            self.le = data.get("le")

    def predecir(self, vector):
        if self.model is None:
            return None, None  # no entrenado
        probs = self.model.predict_proba([vector])[0]
        top_idx = np.argmax(probs)
        titulo = self.le.inverse_transform([top_idx])[0]
        confianza = float(probs[top_idx])
        return titulo, confianza

# --- L√≥gica de juego -------------------------------------------------------
def preguntar_usuario(texto):
    while True:
        r = input(texto + " (s√≠/no/no s√©): ").strip().lower()
        if r in ("s√≠", "si", "s", "no", "n", "no s√©", "nose", "ns", "no se"):
            return r
        print("Respuesta no v√°lida. Escribe 's√≠', 'no' o 'no s√©'.")

def jugar_una_partida(db, model_manager: ModelManager):
    preguntas = db["preguntas"]
    preguntas_ids = preguntas_ids_ordenadas(db)
    candidatos = db["peliculas"][:]
    camino = []  # lista de {id, texto, respuesta}
    # Paso 1: Hacer preguntas secuenciales hasta reducir o hasta agotar preguntas
    for p in preguntas:
        # Si ya queda 1 candidato, podemos detener
        if len(candidatos) <= 1:
            break
        r = preguntar_usuario(p["texto"])
        camino.append({"id": p["id"], "texto": p["texto"], "respuesta": r})
        # Filtrado por atributo si r == 's√≠' o 'no'. Para 'no s√©' no filtramos.
        if r in ("s√≠", "si", "s"):
            candidatos = [c for c in candidatos if c.get("atributos", {}).get(p["atributo"]) == p["valor"]]
        elif r in ("no", "n"):
            candidatos = [c for c in candidatos if c.get("atributos", {}).get(p["atributo"]) != p["valor"]]
        # else no s√© -> no filtramos
    # Si tenemos modelo y suficientes preguntas/muestras, pedir predicci√≥n
    vector_camino = respuestas_a_vector({step["id"]: step["respuesta"] for step in camino}, preguntas_ids)
    suggestion = None
    confianza = 0.0
    if model_manager.model is not None:
        suggestion, confianza = model_manager.predecir(vector_camino)
    # L√≥gica para decidir adivinar
    if suggestion and confianza >= 0.6:
        print(f"Creo que tu pel√≠cula es: {suggestion} (confianza {confianza:.2f})")
        real = preguntar_usuario("¬øEs correcta mi suposici√≥n?")
        if real in ("s√≠","si","s"):
            print("¬°Genial! üéâ")
            # Registrar partida exitosa
            db.setdefault("partidas", []).append({"titulo": suggestion, "camino": camino})
            guardar_db(db)
            return
    # Si quedaron pocos candidatos, preguntar directamente
    if len(candidatos) == 1:
        print("Tu pel√≠cula es:", candidatos[0]["titulo"])
        ok = preguntar_usuario("¬øEs correcta?")
        if ok in ("s√≠","si","s"):
            db.setdefault("partidas", []).append({"titulo": candidatos[0]["titulo"], "camino": camino})
            guardar_db(db)
            return
    # No adivin√≥: pedir ayuda al usuario
    print("No adivin√© tu pel√≠cula üòî")
    titulo_real = input("¬øCu√°l era la pel√≠cula?: ").strip()
    # Re-preguntar por todas las preguntas en orden para registrar el camino completo
    print("Por favor confirma las respuestas a las preguntas para que pueda aprender (s√≠/no/no s√©).")
    camino_final = []
    for p in preguntas:
        r = preguntar_usuario(p["texto"])
        camino_final.append({"id": p["id"], "texto": p["texto"], "respuesta": r})
    # Guardar nueva pel√≠cula (si no existe)
    existe = any(p["titulo"].lower() == titulo_real.lower() for p in db["peliculas"])
    if not existe:
        # intentar extraer atributos b√°sicos a partir de respuestas (ejemplo simple)
        atributos = {}
        for step in camino_final:
            # si la pregunta est√° vinculada a un atributo/valor en DB
            pdef = next((q for q in preguntas if q["id"] == step["id"]), None)
            if pdef and step["respuesta"] in ("s√≠","si","s"):
                atributos[pdef["atributo"]] = pdef["valor"]
        db["peliculas"].append({"titulo": titulo_real, "atributos": atributos, "camino": camino_final})
    else:
        # A√±adir camino a la pelicula existente
        for p in db["peliculas"]:
            if p["titulo"].lower() == titulo_real.lower():
                p.setdefault("camino", []).append(camino_final)
                break
    # Guardar partida en historial
    db.setdefault("partidas", []).append({"titulo": titulo_real, "camino": camino_final})
    guardar_db(db)
    # Re-entrenar modelo con la nueva muestra
    model_manager.entrenar(db)
    print("Gracias ‚Äî he aprendido esta pel√≠cula. Ahora intentar√© hacerlo mejor la pr√≥xima vez.")

# --- Interfaz simple de consola --------------------------------------------
def menu_principal():
    print("Akinator Pel√≠culas (Prototipo) ‚Äî responde con 's√≠', 'no' o 'no s√©'")
    db = cargar_db()
    model_manager = ModelManager()
    model_manager.cargar()
    model_manager.entrenar(db)  # entrenar (o reentrenar) al inicio seg√∫n DB
    while True:
        print("\nOpciones:")
        print("1) Jugar una partida")
        print("2) Mostrar estad√≠sticas b√°sicas")
        print("3) Agregar pregunta manualmente")
        print("4) Salir")
        opc = input("Elige (1-4): ").strip()
        if opc == "1":
            jugar_una_partida(db, model_manager)
        elif opc == "2":
            n_pel = len(db.get("peliculas", []))
            n_preg = len(db.get("preguntas", []))
            n_part = len(db.get("partidas", []))
            print(f"Pel√≠culas en DB: {n_pel}, Preguntas: {n_preg}, Partidas registradas: {n_part}")
        elif opc == "3":
            texto = input("Texto de la pregunta (ej. '¬øEs de terror?'): ").strip()
            atributo = input("Atributo (ej. 'genero'): ").strip()
            valor = input("Valor que representa el 's√≠' (ej. 'Terror'): ").strip()
            pid = atributo + "_" + valor.lower().replace(" ", "_")
            db.setdefault("preguntas", []).append({"id": pid, "texto": texto, "atributo": atributo, "valor": valor})
            guardar_db(db)
            print("Pregunta a√±adida. Te recomiendo jugar una partida para generar ejemplos con la nueva pregunta.")
            # despu√©s de a√±adir pregunta, reentrenar (las nuevas muestras no tendr√°n respuesta -> se usan como 0.5)
            model_manager.entrenar(db)
        elif opc == "4":
            print("¬°Hasta luego!")
            break
        else:
            print("Opci√≥n no v√°lida.")

if __name__ == "__main__":
    menu_principal()