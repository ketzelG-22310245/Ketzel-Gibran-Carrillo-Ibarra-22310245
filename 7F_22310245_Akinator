
import json
import os
import csv
import joblib
from collections import defaultdict

# Intento de importar sklearn y auxiliares; si falla, avisar al usuario
try:
    from sklearn.neural_network import MLPClassifier
    from sklearn.preprocessing import LabelEncoder
    from sklearn.exceptions import ConvergenceWarning
    import warnings
    warnings.filterwarnings("ignore", category=ConvergenceWarning)
except Exception as e:
    raise ImportError(
        "Falta scikit-learn o joblib. Inst√°lalos con:\n\n"
        "    pip install scikit-learn joblib\n\n"
        "Luego vuelve a ejecutar el script.\n\n"
        f"Error original: {e}"
    )

DB_FILE = "akinator.json"
DATASET_FILE = "dataset.csv"
MODEL_FILE = "model.joblib"

GENRES = ["acci√≥n", "comedia", "terror", "romance", "ciencia ficci√≥n"]

# Preguntas fijas (4 por g√©nero) -> usadas como features por el MLP
# Nota: estas preguntas tambi√©n se usan para inicializar el √°rbol.
GENRE_QUESTIONS = {
    "acci√≥n": [
        "¬øHay superh√©roes?",
        "¬øHay persecuciones de autos?",
        "¬øEl protagonista es parte de una franquicia conocida?",
        "¬øHay grandes escenas de lucha?"
    ],
    "comedia": [
        "¬øEl humor es f√≠sico (slapstick)?",
        "¬øEl protagonista es un comediante famoso?",
        "¬øLa historia es sobre una familia disfuncional?",
        "¬øTiene humor negro?"
    ],
    "terror": [
        "¬øInvolucra una casa embrujada?",
        "¬øHay entidades sobrenaturales?",
        "¬øIncluye jump scares frecuentes?",
        "¬øEl antagonista es una criatura/monstruo?"
    ],
    "romance": [
        "¬øLa historia se centra en una pareja?",
        "¬øTranscurre en un colegio/universidad?",
        "¬øEs un drama rom√°ntico (triste)?",
        "¬øHay un tri√°ngulo amoroso?"
    ],
    "ciencia ficci√≥n": [
        "¬øHay viajes espaciales?",
        "¬øIncluye IA o robots?",
        "¬øLa historia trata sobre un futuro dist√≥pico?",
        "¬øHay viajes en el tiempo?"
    ],
}

# -------------------------
# Nodo y serializaci√≥n
# -------------------------
class Nodo:
    def __init__(self, pregunta=None, si=None, no=None, pelicula=None):
        self.pregunta = pregunta
        self.si = si
        self.no = no
        self.pelicula = pelicula

def nodo_a_dict(n):
    if n is None:
        return None
    return {
        "pregunta": n.pregunta,
        "pelicula": n.pelicula,
        "si": nodo_a_dict(n.si),
        "no": nodo_a_dict(n.no)
    }

def dict_a_nodo(d):
    if d is None:
        return None
    return Nodo(
        pregunta=d.get("pregunta"),
        pelicula=d.get("pelicula"),
        si=dict_a_nodo(d.get("si")),
        no=dict_a_nodo(d.get("no"))
    )

# -------------------------
# Guardado / Carga √°rbol
# -------------------------
def guardar_arbol(generos):
    data = {nombre: nodo_a_dict(nodo) for nombre, nodo in generos.items()}
    with open(DB_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

def cargar_arbol():
    if not os.path.exists(DB_FILE):
        return crear_arbol_inicial()
    with open(DB_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    return {nombre: dict_a_nodo(nodo_dict) for nombre, nodo_dict in data.items()}

# -------------------------
# √Årbol inicial expandido
# -------------------------
def crear_arbol_inicial():
    # Por simplicidad, construiremos un √°rbol que pregunta las 4 preguntas
    # secuencialmente para cada g√©nero y termina en dos posibles pel√≠culas.
    # Puedes editar/expandir las hojas iniciales.
    generos = {}

    # Ejemplos de pel√≠culas por g√©nero (hojas iniciales)
    ejemplos = {
        "acci√≥n": ("Avengers: Endgame", "John Wick"),
        "comedia": ("Son como ni√±os", "Ted"),
        "terror": ("El Conjuro", "It (Eso)"),
        "romance": ("A todos los chicos de los que me enamor√©", "Titanic"),
        "ciencia ficci√≥n": ("Interestelar", "Matrix")
    }

    for genero in GENRES:
        qlist = GENRE_QUESTIONS[genero]

        # Construir un camino lineal de 4 preguntas que conduce a dos pel√≠culas
        # Pregunta1 -> Pregunta2 -> Pregunta3 -> Pregunta4 -> [peliculaA/no->peliculaB]
        leaf_yes = Nodo(pelicula=ejemplos[genero][0])
        leaf_no = Nodo(pelicula=ejemplos[genero][1])
        node = Nodo(pregunta=qlist[-1], si=leaf_yes, no=leaf_no)

        # Construir las 3 preguntas superiores
        for q in reversed(qlist[:-1]):
            node = Nodo(pregunta=q, si=node, no=node)  # por defecto, ambos apuntan igual (se puede mejorar)
        generos[genero] = node

    return generos

# -------------------------
# Dataset (CSV) manejo
# -------------------------
def asegurar_dataset():
    if not os.path.exists(DATASET_FILE):
        # Crear cabecera: 20 features + objetivo
        header = []
        for g in GENRES:
            for i in range(1, 5):
                header.append(f"{g}_q{i}")
        header.append("pelicula")
        with open(DATASET_FILE, "w", encoding="utf-8", newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header)

def agregar_ejemplo_a_dataset(feature_vector, pelicula):
    """
    feature_vector: lista de 20 valores (0/1) coincidiendo con el orden de GENRES x 4 preguntas.
    """
    asegurar_dataset()
    row = list(feature_vector) + [pelicula]
    with open(DATASET_FILE, "a", encoding="utf-8", newline='') as f:
        writer = csv.writer(f)
        writer.writerow(row)

def cargar_dataset():
    asegurar_dataset()
    X = []
    y = []
    with open(DATASET_FILE, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        header = next(reader, None)
        for row in reader:
            if len(row) < 21:
                continue
            features = [int(x) for x in row[:-1]]
            label = row[-1]
            X.append(features)
            y.append(label)
    return X, y

# -------------------------
# Modelo (MLP) manejo
# -------------------------
def train_model():
    X, y = cargar_dataset()
    if len(X) < 1:
        # No hay datos suficientes
        return None

    le = LabelEncoder()
    y_enc = le.fit_transform(y)
    model = MLPClassifier(hidden_layer_sizes=(50, ), max_iter=500)
    model.fit(X, y_enc)
    # Guardar modelo y label encoder
    joblib.dump({"model": model, "le": le}, MODEL_FILE)
    return model, le

def cargar_modelo():
    if not os.path.exists(MODEL_FILE):
        return None, None
    data = joblib.load(MODEL_FILE)
    return data.get("model"), data.get("le")

# -------------------------
# Utilidades de I/O validadas
# -------------------------
def pedir_si_no(prompt):
    while True:
        r = input(prompt + " (s√≠/no): ").strip().lower()
        if r in ["s√≠", "si", "s", "yes", "y"]:
            return 1
        if r in ["no", "n"]:
            return 0
        print("Respuesta no v√°lida. Responde 's√≠' o 'no'.")

# -------------------------
# Flujo de juego
# -------------------------
def obtener_vector_features(respuestas_por_genero):
    """
    Construye el vector de 20 features a partir de un diccionario:
      { 'acci√≥n': [1,0,1,0], 'comedia': [0,0,0,0], ... }
    El orden es GENRES en el orden definido y dentro de cada g√©nero q1..q4.
    """
    vector = []
    for g in GENRES:
        vals = respuestas_por_genero.get(g, [0,0,0,0])
        # Si faltan preguntas, rellenar con 0
        vals = vals + [0]*(4 - len(vals))
        vector.extend([int(bool(x)) for x in vals[:4]])
    return vector

def jugar_una_partida(generos, modelo, le):
    print("\nResponde las preguntas del g√©nero correspondiente para que el MLP pueda intentar predecir.")
    # Preguntar g√©nero (una sola vez)
    print("Primero dime el g√©nero de tu pel√≠cula:")
    elegido = None
    for g in GENRES:
        r = pedir_si_no(f"¬øTu pel√≠cula es de {g}?")
        if r == 1:
            elegido = g
            break
    if not elegido:
        print("No supiste escoger un g√©nero. Fin de partida.")
        return modelo, le

    # Hacer las 4 preguntas fijas de ese g√©nero y recopilar respuestas
    respuestas = {}
    for g in GENRES:
        respuestas[g] = [0,0,0,0]  # default
    resp_list = []
    for i, q in enumerate(GENRE_QUESTIONS[elegido]):
        ans = pedir_si_no(q)
        respuestas[elegido][i] = ans
        resp_list.append(ans)

    # Construir vector completo para el MLP
    feat = obtener_vector_features(respuestas)

    # Intento de predicci√≥n por MLP (si modelo existe)
    if modelo is not None and le is not None:
        try:
            probs = modelo.predict_proba([feat])[0]
            idx = probs.argmax()
            conf = probs[idx]
            pred_label = le.inverse_transform([idx])[0]
            # Umbral de confianza para proponer la predicci√≥n
            umbral = 0.60
            if conf >= umbral:
                print(f"\nEl modelo sugiere que tu pel√≠cula es: '{pred_label}' (confianza {conf:.2f}).")
                confirmado = pedir_si_no("¬øEs correcta la predicci√≥n?")
                if confirmado == 1:
                    print("üéâ ¬°Perfecto! El MLP acert√≥.")
                    return modelo, le
                else:
                    print("Ok, no acert√≥. Seguiremos con el √°rbol y aprenderemos.")
            else:
                print(f"\nEl modelo intenta predecir, pero no est√° seguro (confianza {conf:.2f}). Usar√© el √°rbol.")
        except Exception as e:
            print(f"Error durante la predicci√≥n del MLP: {e}. Continuo con el √°rbol.")

    # Si el MLP no acert√≥ o no existe, recorrer el √°rbol del g√©nero seleccionado
    nuevo_subarbol = hacer_pregunta_en_genero(generos[elegido])
    generos[elegido] = nuevo_subarbol
    guardar_arbol(generos)

    # Si el usuario ense√±√≥ una nueva pel√≠cula (aprender), deber√≠amos tener la pel√≠cula final
    # Para registrar un ejemplo en el dataset necesitamos la pel√≠cula elegida.
    # Pedimos confirmaci√≥n: ¬øse adivin√≥? si no, pedir el nombre (el aprender() ya pedir√° y actualizar√° √°rbol).
    # Para capturar el ejemplo, retornamos la pel√≠cula preguntando en el final del flujo:
    pelicula_final = preguntar_pelicula_resultado(generos[elegido])
    if pelicula_final:
        feature_vector = feat  # vector calculado arriba
        agregar_ejemplo_a_dataset(feature_vector, pelicula_final)
        # Reentrenar el modelo en vivo
        modelo_le_tuple = train_model()
        if modelo_le_tuple:
            modelo, le = modelo_le_tuple
            print("Modelo MLP reentrenado en vivo con el nuevo ejemplo ‚úÖ")
    return modelo, le

def hacer_pregunta_en_genero(nodo):
    """Funci√≥n recursiva parecida a la versi√≥n arbol, pero sin volver a preguntar g√©nero."""
    if nodo is None:
        return aprender(Nodo())

    if nodo.pelicula:
        r = input(f"¬øTu pel√≠cula es '{nodo.pelicula}'? (s√≠/no): ").strip().lower()
        if r in ["s√≠", "si", "s"]:
            print("üé¨ ¬°Adivin√© la pel√≠cula!")
            return nodo
        else:
            return aprender(nodo)

    r = input(f"{nodo.pregunta} (s√≠/no): ").strip().lower()
    if r in ["s√≠", "si", "s"]:
        if nodo.si:
            nodo.si = hacer_pregunta_en_genero(nodo.si)
        else:
            nodo.si = aprender(Nodo())
    else:
        if nodo.no:
            nodo.no = hacer_pregunta_en_genero(nodo.no)
        else:
            nodo.no = aprender(Nodo())
    return nodo

def preguntar_pelicula_resultado(subarbol):
    """
    Intenta deducir la pel√≠cula final del sub√°rbol: si la ra√≠z es pel√≠cula, retorno esa.
    Si no, intenta preguntar al usuario directamente el nombre (para garantizar dataset).
    """
    # Si la ra√≠z es hoja con pelicula, retornarla (no se necesita preguntar)
    if subarbol and subarbol.pelicula:
        return subarbol.pelicula
    # Si no, pedir al usuario el nombre final para poder registrar ejemplo
    r = input("Para ayudarnos a aprender: ¬øCu√°l era la pel√≠cula correcta? (escribe el t√≠tulo): ").strip()
    if r:
        return r
    return None

# -------------------------
# Aprendizaje din√°mico (√°rbol)
# -------------------------
def aprender(nodo):
    pelicula_usuario = input("No la adivin√© üòÖ ¬øCu√°l era tu pel√≠cula?: ").strip()
    comparacion = nodo.pelicula if nodo.pelicula else "la que intent√© adivinar"
    nueva_pregunta = input(f"Dime una pregunta que distinga '{pelicula_usuario}' de {comparacion}: ").strip()
    respuesta_correcta = None
    while respuesta_correcta is None:
        rc = input(f"Para '{pelicula_usuario}', ¬øla respuesta ser√≠a 's√≠' o 'no'? ").strip().lower()
        if rc in ["s√≠", "si", "s"]:
            respuesta_correcta = True
        elif rc in ["no", "n"]:
            respuesta_correcta = False
        else:
            print("Respuesta no v√°lida. Responde 's√≠' o 'no'.")

    if respuesta_correcta:
        nuevo_nodo = Nodo(pregunta=nueva_pregunta,
                          si=Nodo(pelicula=pelicula_usuario),
                          no=nodo)
    else:
        nuevo_nodo = Nodo(pregunta=nueva_pregunta,
                          si=nodo,
                          no=Nodo(pelicula=pelicula_usuario))

    print("Gracias, he aprendido algo nuevo ü§ñ")
    return nuevo_nodo

# -------------------------
# Programa principal
# -------------------------
def iniciar_akinator():
    print("üé• Akinator de Pel√≠culas ‚Äî Parte 3 (MLP en vivo) üé¨")
    generos = cargar_arbol()
    asegurar_dataset()

    # Intentar cargar modelo entrenado
    modelo, le = cargar_modelo()
    if modelo is None:
        print("No hay modelo MLP previo. Se entrenar√° si hay ejemplos en dataset.")
        # Intentar entrenar si hay datos
        modelo_le_tuple = train_model()
        if modelo_le_tuple:
            modelo, le = modelo_le_tuple

    while True:
        modelo, le = jugar_una_partida(generos, modelo, le)
        # Preguntar si quiere jugar de nuevo
        cont = input("\n¬øQuieres jugar otra partida? (s√≠/no): ").strip().lower()
        if cont not in ["s√≠", "si", "s"]:
            print("¬°Hasta la pr√≥xima! Guardando datos...")
            guardar_arbol(generos)
            break

if __name__ == "__main__":
    iniciar_akinator()